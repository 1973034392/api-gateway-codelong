# 07 性能优化

## 31. 多级缓存策略

### 为什么采用多级缓存？
1) **性能优化**: L1内存缓存访问速度纳秒级，避免频繁访问Redis；

2) **分布式共享**: L2 Redis缓存跨网关节点共享，保证配置一致性；

3) **容错能力**: Redis异常时仍可使用内存缓存；

4) **成本平衡**: 内存缓存容量有限，Redis提供持久化存储；

5) **实际效果**: 多级缓存可将平均响应时间降低50-70%。

### L1缓存和L2缓存各自的特点是什么？
**L1缓存(内存)**：

1) 使用Hutool的LFU缓存；

2) 访问速度快(纳秒级)；

3) 容量有限(默认1000)；

4) 单机存储；

5) 重启丢失。


**L2缓存(Redis)**：

1) 分布式存储；

2) 访问速度慢(毫秒级)；

3) 容量大；

4) 支持持久化；

5) 需要网络开销。

### 缓存的淘汰策略是什么？
1) **L1缓存**: 使用LFU(Least Frequently Used)策略，淘汰访问频率最低的数据；

2) **容量淘汰**: 缓存满时，删除最低频率的数据；

3) **TTL淘汰**: 定时清理超过生存时间的数据；

4) **空闲淘汰**: 删除超过最大空闲时间未被访问的数据；

5) **手动清理**: 配置变更时主动清理相关缓存。

### 如何保证缓存的一致性？
1) **数据库为主**: 数据库是真实数据源，缓存为辅助；

2) **写入同步**: 数据写入数据库后同时更新缓存；

3) **删除同步**: 数据删除时同时删除缓存；

4) **定时同步**: 定时任务从数据库同步数据到缓存；

5) **事件驱动**: Redis Pub/Sub发布更新事件，网关核心实时更新。

## 32. 连接池优化

### HTTP连接池的配置参数是什么？
1) **maxConnTotal**: 最大连接数(200)；

2) **maxConnPerRoute**: 单路由最大连接数(20)；

3) **soTimeout**: Socket超时时间(5000ms)；

4) **connectTimeout**: 连接超时时间；

5) **connectionRequestTimeout**: 从连接池获取连接的超时时间。

### 如何设置最大连接数和单路由最大连接数？
1) **maxConnTotal**: 设置为200，支持200个并发连接；

2) **maxConnPerRoute**: 设置为20，每个后端服务最多20个连接；

3) **计算方式**: maxConnPerRoute = maxConnTotal / 后端服务数量；

4) **调优**: 根据实际并发量和后端服务数量调整；

5) **监控**: 监控连接池使用率，及时调整参数。

### 如何实现连接的自动回收？
1) **连接复用**: HTTP连接池自动复用连接，减少创建销毁开销；

2) **空闲回收**: 定时清理空闲连接，释放资源；

3) **异常关闭**: 异常请求后关闭连接，防止资源泄露；

4) **优雅关闭**: 应用关闭时调用`asyncHttpClient.close()`关闭所有连接；

5) **监控告警**: 监控连接泄露，及时发现问题。

### 连接池的性能指标有哪些？
1) **连接数**: 当前活跃连接数、空闲连接数、总连接数；

2) **吞吐量**: 每秒处理的请求数(QPS)；

3) **响应时间**: 平均响应时间、P95、P99；

4) **错误率**: 连接失败率、超时率；

5) **资源利用**: 连接池使用率、内存占用。

## 33. 零拷贝优化

### 什么是零拷贝？
1) **定义**: 数据在内存中不需要复制，直接从源地址传输到目标地址；

2) **传统方式**: 数据需要在内核空间和用户空间之间复制多次；

3) **零拷贝方式**: 使用DMA(Direct Memory Access)直接传输数据；

4) **优势**: 减少CPU开销，提高传输效率；

5) **应用**: 文件传输、网络通信等场景。

### 在这个项目中如何实现零拷贝？
1) **Netty ByteBuf**: 使用Netty的DirectBuffer(堆外内存)，避免JVM堆内存复制；

2) **FileRegion**: 使用FileRegion实现文件零拷贝传输；

3) **Unpooled**: 使用`Unpooled.wrappedBuffer()`包装现有数据，避免复制；

4) **HttpObjectAggregator**: 聚合HTTP消息时使用零拷贝技术；

5) **内存池**: 使用内存池复用ByteBuf，减少分配释放开销。

### 零拷贝的性能提升有多少？
1) **CPU占用**: 降低30-50%；

2) **内存占用**: 降低20-30%；

3) **吞吐量**: 提升20-40%；

4) **延迟**: 降低10-20%；

5) **实际数据**: 在大文件传输场景下，性能提升最明显。

### 零拷贝的适用场景有哪些？
1) **文件传输**: 大文件下载、上传；

2) **网络通信**: 高吞吐量的网络传输；

3) **数据库**: 大数据量查询结果返回；

4) **日志系统**: 日志文件的读写；

5) **限制**: 小数据量场景效果不明显，反而可能增加复杂度。

## 34. 异步非阻塞架构

### 为什么采用异步非阻塞架构？
1) **线程利用率**: 异步不阻塞线程，一个线程可处理多个请求；

2) **并发能力**: 支持数万并发连接，同步仅能支持数百；

3) **资源节省**: 减少线程创建销毁开销，降低内存占用；

4) **吞吐量提升**: 异步吞吐量比同步提升3-5倍；

5) **响应时间**: 平均延迟降低30-50%。

### Netty NIO模型的优势是什么？
1) **事件驱动**: 基于事件循环，高效处理I/O事件；

2) **非阻塞I/O**: 使用NIO Selector，一个线程管理多个连接；

3) **零拷贝**: 支持DirectBuffer和FileRegion；

4) **高性能**: 经过优化，性能远超传统BIO；

5) **可扩展**: 支持自定义处理器，灵活扩展功能。

### 异步处理相比同步处理的性能提升有多少？
1) **吞吐量**: 异步提升3-5倍；

2) **延迟**: 异步降低30-50%；

3) **并发能力**: 异步支持数万连接，同步仅数百；

4) **资源利用**: 异步线程利用率提升2-3倍；

5) **实际数据**: 在网关场景下，异步QPS可达10万+，同步仅2-3万。

### 如何处理异步处理中的错误？
1) **异常捕获**: 使用try-catch捕获异步任务中的异常；

2) **CompletableFuture**: 使用`exceptionally()`处理异常；

3) **超时控制**: 使用`orTimeout()`设置超时，防止无限等待；

4) **日志记录**: 记录异常堆栈，便于问题排查；

5) **降级处理**: 异常时返回默认值或降级响应，保证系统可用性。

