# 25 网络编程问题

## 126. TCP/IP协议

### TCP/IP协议的基本原理是什么？
TCP/IP是互联网的核心协议栈：

1) **IP层**：负责寻址和路由，将数据包从源主机传输到目标主机；

2) **TCP层**：提供可靠的、面向连接的字节流服务，保证数据顺序和完整性；

3) **三次握手**：建立连接时通过SYN、SYN-ACK、ACK确保双方准备就绪；

4) **四次挥手**：关闭连接时通过FIN、ACK、FIN、ACK确保数据传输完成；

5) **流量控制**：通过滑动窗口控制发送速率；

6) **拥塞控制**：通过慢启动、拥塞避免、快速重传等算法避免网络拥塞。

### TCP连接的建立和关闭过程是什么？
**三次握手建立连接**：

1) 客户端发送SYN包，进入SYN_SENT状态；

2) 服务端收到SYN，回复SYN-ACK，进入SYN_RCVD状态；

3) 客户端收到SYN-ACK，回复ACK，双方进入ESTABLISHED状态。


**四次挥手关闭连接**：

1) 客户端发送FIN，进入FIN_WAIT_1；

2) 服务端回复ACK，进入CLOSE_WAIT；

3) 服务端发送FIN，进入LAST_ACK；

4) 客户端回复ACK，进入TIME_WAIT（等待2MSL后关闭）。项目中Netty和HTTP客户端都基于TCP连接。

### 如何处理TCP的粘包和拆包问题？
项目使用Netty处理粘包拆包：

1) **固定长度**：每个消息固定长度，不足补齐；

2) **分隔符**：使用特殊字符分隔消息，如`\n`；

3) **长度字段**：消息头包含长度字段，根据长度读取；

4) **HTTP协议**：项目使用`HttpObjectAggregator`自动处理HTTP消息的粘包拆包，根据Content-Length或Transfer-Encoding判断消息边界；

5) **自定义协议**：可使用`LengthFieldBasedFrameDecoder`处理自定义协议。

### 如何优化TCP的性能？
1) **TCP_NODELAY**：禁用Nagle算法，减少延迟，适合小数据包场景；

2) **SO_KEEPALIVE**：启用TCP心跳检测，及时发现断开的连接；

3) **SO_RCVBUF/SO_SNDBUF**：调整接收/发送缓冲区大小；

4) **连接复用**：使用连接池复用TCP连接，避免频繁建立关闭；

5) **长连接**：使用HTTP Keep-Alive保持连接。项目中HTTP连接池配置最大200连接，单路由20连接，复用TCP连接提高性能。

## 127. HTTP协议

### HTTP协议的基本原理是什么？
HTTP是应用层协议，基于TCP实现：

1) **请求-响应模型**：客户端发送请求，服务端返回响应；

2) **无状态**：每个请求独立，不保存状态信息；

3) **文本协议**：请求和响应都是文本格式（HTTP/1.x）；

4) **方法**：GET、POST、PUT、DELETE等；

5) **状态码**：200成功、404未找到、500服务器错误等；

6) **头部**：Content-Type、Content-Length、Authorization等。项目支持GET、POST、PUT、DELETE四种方法。

### HTTP请求和响应的格式是什么？
**请求格式**：

```
GET /api/test?id=1 HTTP/1.1
Host: localhost:8888
Authorization: Bearer token
Content-Type: application/json

{"key":"value"}
```

包含：请求行（方法、URI、版本）、请求头、空行、请求体。**响应格式**：

```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 25

{"code":200,"msg":"ok"}
```

包含：状态行（版本、状态码、原因短语）、响应头、空行、响应体。

### HTTP的各个版本有什么区别？
1) **HTTP/1.0**：短连接，每个请求建立一次连接；

2) **HTTP/1.1**：长连接（Keep-Alive），支持管道化，但存在队头阻塞；

3) **HTTP/2**：二进制协议，多路复用，头部压缩，服务端推送；

4) **HTTP/3**：基于QUIC（UDP），解决队头阻塞，更快的连接建立。项目使用HTTP/1.1，通过连接池实现连接复用。

### 如何优化HTTP的性能？
1) **连接复用**：使用HTTP/1.1 Keep-Alive或HTTP/2多路复用；

2) **压缩**：启用Gzip压缩响应体；

3) **缓存**：使用Cache-Control、ETag等缓存机制；

4) **减少请求**：合并资源、使用雪碧图；

5) **CDN加速**：静态资源使用CDN；

6) **异步非阻塞**：使用异步HTTP客户端。项目使用Apache HttpAsyncClient异步发送请求，连接池复用连接，提高性能。

## 128. 长连接与短连接

### 长连接和短连接的区别是什么？
**短连接**：每次请求建立一次TCP连接，请求完成后立即关闭。**优点**：实现简单，无需管理连接状态。**缺点**：频繁建立关闭连接，开销大，性能差。

**长连接**：建立一次TCP连接，多次请求复用该连接。**优点**：减少连接开销，提高性能。**缺点**：需要管理连接状态，处理超时和异常。项目使用长连接，HTTP/1.1默认Keep-Alive，连接池管理连接生命周期。

### 如何实现长连接？
1) **HTTP Keep-Alive**：HTTP/1.1默认启用，通过`Connection: keep-alive`头部声明；

2) **连接池**：使用连接池管理长连接，复用空闲连接；

3) **心跳检测**：定期发送心跳包检测连接是否存活；

4) **超时控制**：设置空闲超时，超时后关闭连接；

5) **异常处理**：连接异常时自动重连。项目中`PoolingAsyncClientConnectionManager`管理HTTP长连接，最大200连接，空闲30秒后验证。

### 长连接的优缺点是什么？
**优点**：

1) **性能提升**：避免频繁建立关闭连接，减少三次握手和四次挥手开销；

2) **降低延迟**：复用连接，请求立即发送；

3) **减少资源占用**：减少TIME_WAIT状态的连接数。


**缺点**：

1) **资源占用**：长时间占用连接资源；

2) **管理复杂**：需要处理超时、异常、心跳等；

3) **连接泄漏**：未正确释放连接导致资源泄漏。项目通过连接池自动管理，定期清理空闲连接。

### 如何处理长连接的超时？
1) **连接超时**：建立连接的超时时间，项目设置5秒；

2) **Socket超时**：读写数据的超时时间，项目设置5秒；

3) **空闲超时**：连接空闲多久后关闭，项目设置30秒验证，60秒清理；

4) **请求超时**：单个请求的超时时间，项目默认15秒；

5) **超时处理**：超时后关闭连接，记录日志，返回错误。配置：`IOReactorConfig.setSoTimeout(5000)`、`setValidateAfterInactivity(30_000)`、`evictIdleConnections(60L, TimeUnit.SECONDS)`。

## 129. 连接复用

### 什么是连接复用？
连接复用是指多个请求共享同一个TCP连接，避免频繁建立关闭连接。实现方式：

1) **HTTP/1.1 Keep-Alive**：一个连接上串行发送多个请求；

2) **HTTP/2多路复用**：一个连接上并行发送多个请求；

3) **连接池**：维护一组连接，请求时从池中获取，使用完归还。项目使用连接池实现连接复用，HTTP连接池最大200连接，单路由20连接。

### 如何实现HTTP连接的复用？
项目使用Apache HttpAsyncClient连接池：

```java
PoolingAsyncClientConnectionManager connectionManager =
    PoolingAsyncClientConnectionManagerBuilder.create()
        .setMaxConnTotal(200)           // 最大连接数
        .setMaxConnPerRoute(20)         // 单路由最大连接数
        .build();

CloseableHttpAsyncClient client = HttpAsyncClients.custom()
    .setConnectionManager(connectionManager)
    .build();
```

**工作流程**：

1) 请求时从连接池获取连接；

2) 如果有空闲连接，直接复用；

3) 如果无空闲连接且未达上限，创建新连接；

4) 如果达到上限，等待或拒绝；

5) 请求完成后归还连接到池中。

### 连接复用的优缺点是什么？
**优点**：

1) **性能提升**：避免TCP三次握手和四次挥手，减少延迟；

2) **资源节省**：减少连接数，降低服务器负载；

3) **吞吐量提升**：更多请求可以并发处理。


**缺点**：

1) **复杂性**：需要管理连接池，处理连接状态；

2) **资源占用**：空闲连接占用资源；

3) **连接泄漏**：未正确归还连接导致资源耗尽。项目通过定期清理空闲连接（60秒）和验证连接可用性（30秒）避免问题。

### 连接复用对性能的影响有多大？
**性能提升**：

1) **延迟降低**：避免TCP握手，延迟降低50-100ms；

2) **QPS提升**：单机QPS可提升30-50%；

3) **资源节省**：连接数减少70-80%；

4) **CPU降低**：减少连接建立销毁的CPU开销。


**测试数据**：短连接QPS约3000，长连接+连接池QPS约5000-8000，提升67-167%。项目中连接池是性能优化的关键，配合异步非阻塞实现高性能。

## 130. 网络超时

### 如何设置网络超时？
项目设置多级超时：

1) **连接超时**：建立TCP连接的超时，`IOReactorConfig.setSoTimeout(5000)`设置5秒；

2) **Socket超时**：读写数据的超时，同样5秒；

3) **请求超时**：单个请求的总超时，`ExecutorHandler`中默认15秒，可根据服务动态调整；

4) **空闲超时**：连接空闲多久后验证/关闭，30秒验证，60秒清理；

5) **Dubbo超时**：`reference.setTimeout(3000)`设置3秒。

### 网络超时的处理流程是什么？
1) **超时检测**：通过定时器或事件循环检测超时；

2) **取消请求**：超时后取消正在执行的请求；

3) **关闭连接**：关闭超时的连接，避免资源泄漏；

4) **异常处理**：捕获`TimeoutException`，记录日志；

5) **返回错误**：向客户端返回超时错误；

6) **重试机制**：可选择性重试超时请求；

7) **监控告警**：超时率超过阈值时告警。项目中超时通过`CompletableFuture.get(timeout)`实现，超时后返回错误Result。

### 如何区分不同类型的超时？
1) **连接超时**：`ConnectTimeoutException`，表示无法建立TCP连接，可能是网络不通或服务未启动；

2) **Socket超时**：`SocketTimeoutException`，表示连接建立后读写超时，可能是服务处理慢或网络延迟；

3) **请求超时**：`TimeoutException`，表示整个请求超时，包含连接、发送、接收、处理时间；

4) **空闲超时**：连接空闲超时，由连接池管理；

5) **业务超时**：业务逻辑处理超时。通过异常类型和日志区分。

### 如何优化网络超时的设置？
1) **分级设置**：不同服务设置不同超时，快速服务3秒，慢速服务10秒；

2) **动态调整**：根据历史响应时间动态调整超时，项目中`serviceTimeoutCache`记录服务超时配置；

3) **P99超时**：根据P99响应时间设置超时，避免偶尔的慢请求；

4) **重试策略**：超时后重试，但要避免雪崩；

5) **熔断降级**：连续超时时熔断，快速失败；

6) **监控优化**：监控超时率，持续优化超时配置。项目中超时失败时会增加超时时间（最多30秒），避免频繁超时。

