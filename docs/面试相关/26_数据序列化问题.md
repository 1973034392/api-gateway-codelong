# 26 数据序列化问题

## 131. JSON序列化

### 系统中使用了哪些JSON序列化库？
项目中使用了两个JSON序列化库：

1) **Fastjson 2.0.52**：用于网关核心的HTTP响应序列化（`RequestResultUtil`中使用`JSON.toJSONString()`）；

2) **Jackson（GenericJackson2JsonRedisSerializer）**：用于Redis的Value序列化，在`RedisConfig`中配置。

### JSON序列化的性能如何？
Fastjson性能优异，序列化速度快，适合高并发场景。Jackson稳定性好，与Spring生态集成紧密。项目中Fastjson用于热路径（请求响应），Jackson用于Redis缓存，性能表现良好。

### 如何处理JSON序列化的异常？
通过全局异常处理器`GlobalExceptionHandler`捕获序列化异常，记录日志并返回统一错误响应。对于Redis序列化异常，会降级到本地缓存或重新查询数据库。

### 如何优化JSON序列化的性能？
1) 使用Fastjson的高性能序列化；

2) 避免序列化大对象，只返回必要字段；

3) 使用`@JsonIgnore`忽略不需要的字段；

4) 对于频繁序列化的对象，考虑使用对象池复用；

5) Redis序列化使用Jackson的类型信息，避免反序列化失败。

## 132. 对象序列化

### 什么是对象序列化？
对象序列化是将Java对象转换为字节流的过程，用于网络传输或持久化存储。反序列化是将字节流还原为Java对象。

### 系统中是否使用了对象序列化？
是的。项目中所有返回结果类（`Result`、`HttpStatement`等）都实现了`Serializable`接口，支持Java对象序列化。Redis存储时使用Jackson进行JSON序列化。

### 对象序列化的安全性如何？
项目使用Jackson序列化，相对安全。避免使用Java原生序列化（存在反序列化漏洞）。对于敏感数据（如密码），在序列化前已加密处理，不直接序列化明文。

### 如何处理序列化的版本兼容性？
1) 实体类添加`serialVersionUID`字段；

2) 使用`@JsonIgnoreProperties(ignoreUnknown = true)`忽略未知字段；

3) 新增字段提供默认值；

4) 避免删除或修改已有字段类型；

5) 通过版本号字段标识数据版本。

## 133. 序列化的性能

### 序列化对性能的影响有多大？
序列化是CPU密集型操作，对性能有一定影响。项目中通过异步处理和缓存优化，将序列化开销控制在可接受范围内（响应时间<10ms）。

### 如何优化序列化的性能？
1) 使用高性能序列化库（Fastjson）；

2) 减少序列化对象的大小；

3) 使用缓存避免重复序列化；

4) 异步序列化，不阻塞主线程；

5) 对于大对象使用流式序列化。

### 如何选择合适的序列化方式？
1) **HTTP响应**：使用Fastjson，性能优先；

2) **Redis存储**：使用Jackson，兼容性好；

3) **Dubbo调用**：使用Hessian2（Dubbo默认），跨语言支持；

4) **日志记录**：使用JSON，可读性好；

5) **持久化**：使用Protobuf或Avro，体积小。

### 序列化的大小对网络传输的影响有多大？
影响显著。JSON序列化后体积较大，项目中通过以下方式优化：

1) 只返回必要字段；

2) 使用短字段名；

3) 对大数据使用Gzip压缩；

4) 考虑使用二进制序列化（Protobuf）减少体积50%以上。

