# 05 安全与认证

## 26. JWT认证机制

### JWT的基本结构是什么？
JWT由三部分组成，用`.`分隔：

1) **Header(头部)**: 包含令牌类型(JWT)和签名算法(HMAC256)；

2) **Payload(载荷)**: 包含声明(claims)，如用户ID、过期时间、安全组key等；

3) **Signature(签名)**: 使用密钥对前两部分进行签名，防止篡改。例如：`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U`

### 如何生成和验证JWT令牌？
**生成**:

1) 创建Header和Payload；

2) 使用密钥和HMAC256算法对Header.Payload进行签名；

3) 返回Header.Payload.Signature。**验证**:

1) 分离Header、Payload、Signature；

2) 使用密钥重新计算签名；

3) 比较计算结果与提供的Signature是否一致；

4) 检查过期时间是否超期；

5) 验证通过则提取Payload中的信息。

### JWT令牌的过期时间如何设置？
1) **过期时间**: 30天(30L * 24 * 60 * 60 * 1000毫秒)；

2) **设置方式**: 在生成令牌时添加`expiresAt`声明，值为当前时间+30天；

3) **验证时检查**: 验证令牌时检查当前时间是否超过`expiresAt`；

4) **过期处理**: 过期令牌返回401错误，提示重新登录；

5) **刷新机制**: 可实现令牌刷新机制，允许用户在过期前刷新令牌。

### 如何处理令牌过期的情况？
1) **检测过期**: 验证令牌时检查过期时间；

2) **返回错误**: 过期时返回HTTP 401状态码和"令牌已过期"错误信息；

3) **客户端处理**: 客户端收到401错误后，提示用户重新登录；

4) **刷新令牌**: 可实现刷新令牌机制，用户可使用刷新令牌获取新的访问令牌；

5) **日志记录**: 记录过期令牌的访问事件，便于安全审计。

## 27. 安全组标识

### 什么是安全组标识？
1) **定义**: 安全组标识是一个字符串，用于标识请求的来源和权限；

2) **组成**: 包含`safeKey`(标识符)和`safeSecret`(密钥)两部分；

3) **作用**: 用于验证请求的合法性和权限；

4) **存储**: 在JWT的Payload中存储`safeKey`，使用`safeSecret`进行签名；

5) **示例**: `safeKey="user-service"`, `safeSecret="abc123xyz"`。

### 安全组标识如何用于权限控制？
1) **接口级权限**: 为每个接口配置允许的安全组列表；

2) **请求验证**: 验证请求的安全组是否在允许列表中；

3) **细粒度控制**: 不同接口可配置不同的安全组，实现细粒度权限控制；

4) **动态配置**: 安全组配置可动态更新，无需重启应用；

5) **审计日志**: 记录每个请求的安全组信息，便于安全审计。

### 如何验证安全组标识？
1) **提取令牌**: 从HTTP请求头`Authorization`中提取JWT令牌；

2) **验证签名**: 使用配置的`safeSecret`验证令牌签名；

3) **提取safeKey**: 从令牌Payload中提取`safeKey`声明；

4) **比对配置**: 将提取的`safeKey`与配置的`safeKey`进行比对；

5) **返回结果**: 匹配则验证通过，不匹配则返回401错误。

### 安全组标识与JWT的关系是什么？
1) **包含关系**: 安全组标识(safeKey)存储在JWT的Payload中；

2) **签名关系**: JWT使用安全组的密钥(safeSecret)进行签名；

3) **双重验证**: 验证JWT时同时验证签名和safeKey，实现双重保护；

4) **防篡改**: 即使攻击者修改了Payload中的safeKey，签名也会失效；

5) **权限映射**: safeKey用于映射到具体的权限和资源。

## 28. 请求认证流程

### 请描述请求认证的完整流程
1) **请求到达**: 客户端发送HTTP请求，在`Authorization`头中包含JWT令牌；

2) **URI解析**: 网关解析请求URI，从缓存中获取接口声明；

3) **认证检查**: 检查接口是否需要认证(isAuth标志)；

4) **令牌提取**: 从`Authorization`头中提取令牌(格式：`Bearer {token}`)；

5) **令牌验证**: 调用`JwtUtils.verify()`验证令牌有效性；

6) **权限检查**: 验证safeKey是否匹配；

7) **放行或拒绝**: 验证通过则放行请求，失败则返回401错误。

### 认证失败时如何处理？
1) **返回状态码**: 返回HTTP 401(Unauthorized)状态码；

2) **错误信息**: 返回错误消息如"没有权限访问该接口"或"令牌无效"；

3) **日志记录**: 记录认证失败事件，包含请求信息和失败原因；

4) **监控告警**: 认证失败次数过多时触发告警，可能表示安全攻击；

5) **中断处理**: 立即中断请求处理，不继续执行后续处理器。

### 如何实现接口级的权限控制？
1) **接口配置**: 为每个接口配置`isAuth`标志和允许的安全组列表；

2) **动态检查**: 在`AuthorizationHandler`中检查接口的权限配置；

3) **细粒度控制**: 不同接口可配置不同的权限要求；

4) **缓存优化**: 将接口权限配置缓存在内存中，避免频繁查询；

5) **热更新**: 权限配置变化时通过Redis Pub/Sub实时推送，无需重启应用。

### 如何处理认证异常？
1) **异常捕获**: 在`AuthorizationHandler`中使用try-catch捕获所有异常；

2) **异常分类**: 区分不同类型的异常(令牌格式错误、签名验证失败、过期等)；

3) **错误响应**: 根据异常类型返回相应的错误信息；

4) **日志记录**: 记录异常堆栈，便于问题排查；

5) **降级处理**: 如果认证系统故障，可降级为允许所有请求通过(仅在必要时)。

