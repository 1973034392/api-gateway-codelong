# 37 算法与数据结构问题

## 191. LFU缓存的实现

### LFU缓存的核心数据结构是什么？
使用三个数据结构：HashMap存储key-value，HashMap存储key-频率，HashMap存储频率-LinkedHashSet(存储该频率的所有key)。

### 如何实现频率的更新？
访问或更新key时，获取其当前频率，从旧频率的集合中移除，频率+1后加入新频率的集合。

### 如何实现缓存的淘汰？
当容量满时，找到最小频率对应的集合，移除其中最早添加的元素（LinkedHashSet保证顺序）。

### LFU缓存的时间复杂度是多少？
get/put操作时间复杂度为O(1)，因为所有操作都是HashMap和LinkedHashSet的常数时间操作。

## 192. 一致性哈希

### 一致性哈希的原理是什么？
将哈希空间映射为一个圆环，服务器和数据都映射到圆环上，数据顺时针查找第一个服务器节点。

### 如何实现一致性哈希？
使用TreeMap存储虚拟节点和真实节点的映射，每个真实节点创建多个虚拟节点以均衡分布。查询时使用tailMap找到大于等于key的第一个节点。

### 一致性哈希的优缺点是什么？
优点：节点增删时只影响相邻节点的数据迁移，迁移量少。缺点：虚拟节点数量多时占用内存，节点分布不均时需要调整虚拟节点数。

### 一致性哈希在分布式系统中的应用？
用于分布式缓存（Redis集群）、负载均衡、分布式存储等场景，保证数据分布均衡且节点变化时迁移量最小。

## 193. 布隆过滤器

### 布隆过滤器的原理是什么？
使用位数组和多个哈希函数，添加元素时将其通过多个哈希函数映射到位数组的多个位置并设为1，查询时检查这些位置是否都为1。

### 如何实现布隆过滤器？
初始化一个位数组，定义k个独立的哈希函数。add操作：对元素计算k个哈希值，将对应位置设为1。contains操作：计算k个哈希值，检查所有位置是否都为1。

### 布隆过滤器的误判率如何计算？
误判率 = (1 - e^(-kn/m))^k，其中k为哈希函数个数，n为元素个数，m为位数组大小。通常选择k=ln(2)*m/n时误判率最低。

### 布隆过滤器在缓存穿透中的应用？
在缓存前加布隆过滤器，存储所有有效数据的key。查询时先检查布隆过滤器，若不存在则直接返回，避免查询数据库，防止缓存穿透。

## 194. 跳表

### 跳表的原理是什么？
在有序链表基础上，为每个节点添加多层指针，每层指针跳过一定数量的节点，形成多层索引结构，实现快速查找。

### 如何实现跳表？
每个节点包含多个指针指向不同层级的下一个节点。插入时随机决定节点的层数，更新各层指针。查询时从最高层开始，逐层向下查找。

### 跳表的时间复杂度是多少？
查询、插入、删除的平均时间复杂度为O(log n)，最坏情况为O(n)。空间复杂度为O(n)。

### 跳表与平衡树的区别是什么？
跳表实现简单，无需复杂的旋转操作；平衡树实现复杂但性能更稳定。跳表支持范围查询，平衡树也支持。跳表在并发环境下更容易实现。

## 195. 红黑树

### 红黑树的原理是什么？
一种自平衡的二叉搜索树，通过给节点着色（红或黑）并遵循特定规则，保证树的高度平衡，从而保证查询、插入、删除的时间复杂度为O(log n)。

### 红黑树的性质有哪些？
1. 每个节点是红色或黑色；2. 根节点是黑色；3. 叶子节点（NIL）是黑色；4. 红色节点的子节点必须是黑色；5. 从任意节点到其叶子节点的所有路径包含相同数量的黑色节点。

### 如何实现红黑树的插入和删除？
插入：按二叉搜索树规则插入红色节点，然后通过旋转和重新着色修复违反的性质。删除：删除节点后，通过旋转和重新着色恢复红黑树性质。

### 红黑树在Java中的应用？
TreeMap和TreeSet内部使用红黑树实现，HashMap在链表长度超过8时也会转换为红黑树以提高性能。

## 196. 哈希表

### 哈希表的原理是什么？
通过哈希函数将key映射到数组索引，实现O(1)的查询、插入、删除。哈希函数应该均匀分布，减少冲突。

### 如何处理哈希冲突？
链地址法：冲突的元素存储在链表中。开放寻址法：寻找下一个空闲位置。双哈希法：使用第二个哈希函数。Java的HashMap使用链地址法，当链表长度超过8时转换为红黑树。

### 哈希表的扩容机制是什么？
当负载因子（元素数/容量）超过阈值（通常0.75）时，创建新的更大数组（通常2倍），重新计算所有元素的哈希值并插入新数组。

### 哈希表的性能如何？
平均情况下查询、插入、删除时间复杂度为O(1)。最坏情况下为O(n)（所有元素哈希到同一位置）。空间复杂度为O(n)。

## 197. 堆

### 堆的原理是什么？
完全二叉树，满足堆性质：最大堆中父节点大于等于子节点，最小堆中父节点小于等于子节点。通常用数组表示，索引i的左子节点为2i+1，右子节点为2i+2。

### 如何实现最小堆和最大堆？
使用数组存储元素。插入时添加到末尾，然后向上调整（上浮）。删除时移除根节点，将末尾元素放到根，然后向下调整（下沉）。

### 堆的应用场景有哪些？
优先队列、堆排序、求Top K元素、中位数查询、任务调度等。

### 堆的时间复杂度是多少？
插入、删除、获取最值的时间复杂度为O(log n)。建堆的时间复杂度为O(n)。空间复杂度为O(n)。

## 198. 图的遍历

### 图的遍历算法有哪些？
深度优先搜索（DFS）、广度优先搜索（BFS）、拓扑排序、最短路径算法（Dijkstra、Bellman-Ford）等。

### 如何实现深度优先搜索？
使用递归或栈。递归方式：访问节点，标记为已访问，递归访问所有未访问的邻接节点。栈方式：将起点入栈，循环弹出栈顶，访问并将其未访问的邻接节点入栈。

### 如何实现广度优先搜索？
使用队列。将起点入队，循环出队，访问节点，将其所有未访问的邻接节点入队。

### 图的遍历在网络中的应用？
网络拓扑发现、路由算法、社交网络分析、推荐系统等。

## 199. 动态规划

### 动态规划的原理是什么？
将复杂问题分解为子问题，存储子问题的解以避免重复计算。基于最优子结构和重叠子问题两个特性。

### 如何识别动态规划问题？
问题具有最优子结构（最优解由子问题的最优解组成）、重叠子问题（相同子问题多次出现）、无后效性（当前状态只依赖于之前的状态）。

### 如何实现动态规划的解决方案？
自顶向下（记忆化搜索）：递归求解，用哈希表存储已计算结果。自底向上（制表法）：从基础情况开始，逐步构建更大的问题的解。

### 动态规划的时间复杂度如何分析？
时间复杂度 = 子问题个数 × 每个子问题的求解时间。空间复杂度通常为O(子问题个数)。

## 200. 贪心算法

### 贪心算法的原理是什么？
每一步都做出当前看起来最优的选择，希望最终得到全局最优解。不回溯，不考虑全局最优。

### 如何识别贪心算法问题？
问题具有贪心选择性质（全局最优解可以通过一系列局部最优选择得到）和最优子结构（问题的最优解包含子问题的最优解）。

### 如何实现贪心算法的解决方案？
1. 建立数学模型描述问题；
2. 找出贪心选择的标准；
3. 证明贪心选择的正确性；
4. 按贪心标准逐步选择，构建最优解。

### 贪心算法的正确性如何证明？
使用反证法或交换论证法。反证法：假设贪心解不是最优解，推导矛盾。交换论证法：证明任何非贪心的最优解都可以通过交换变成贪心解而不降低质量。

