# 23 代码设计与实现细节

## 111. 责任链模式的实现

### 责任链模式在这个项目中如何实现？
项目中有两层责任链：

1) **Netty Pipeline责任链**：`ServerHandlerInitializer`中配置的Handler链：`HttpRequestDecoder` → `HttpResponseEncoder` → `HttpObjectAggregator` → `AuthorizationHandler` → `PreExecutorHandler` → `ExecutorHandler` → `PostExecutorHandler` → `ResultHandler`；

2) **自定义处理器责任链**：`PreExecutorHandler`和`PostExecutorHandler`内部维护的自定义处理器列表，通过`@Order`注解排序执行。

### 处理器链的构建过程是什么？
1) **Netty链构建**：在`ServerHandlerInitializer.initChannel()`中通过`pipeline.addLast()`依次添加Handler；

2) **自定义链构建**：Spring自动扫描所有实现`CustomPreHandler`/`CustomPostHandler`接口的Bean，在`PreExecutorHandler`/`PostExecutorHandler`构造函数中注入并按Order排序；

3) **并行/串行分类**：`PreExecutorHandler`将处理器分为并行和串行两组，并行处理器通过`CompletableFuture.allOf()`并发执行，串行处理器通过`thenCompose()`链式执行。

### 如何在运行时动态添加处理器？
虽然项目未实现运行时动态添加，但可通过以下方式实现：

1) **动态注册Bean**：使用`BeanDefinitionRegistry`动态注册处理器Bean；

2) **刷新处理器列表**：在`PreExecutorHandler`中提供`addHandler()`方法，将新处理器添加到列表并重新排序；

3) **热加载**：通过配置中心下发处理器类名，使用类加载器动态加载；

4) **SPI扩展**：通过SPI机制加载外部处理器。

### 如何实现处理器的跳过和中断？
1) **中断机制**：前置处理器返回非null的`Result`对象时，`PreExecutorHandler`立即调用`channel.writeAndFlush()`返回响应并return，后续处理器不执行；

2) **跳过机制**：处理器返回null表示继续执行下一个处理器；

3) **异常处理**：处理器抛出异常时，根据`isFailFast()`决定是否中断链路；

4) **条件执行**：处理器内部可根据条件判断是否执行逻辑。例如限流处理器检测到超限时返回限流错误，中断后续处理。

## 112. 策略模式的应用

### 策略模式在这个项目中的应用场景有哪些？
1) **协议策略**：通过`BaseConnection`接口抽象，`HTTPConnection`和`DubboConnection`实现不同协议的调用策略；

2) **执行器策略**：通过`BaseExecutor`接口，`DefaultHTTPExecutor`和`DefaultDubboExecutor`实现不同的执行策略；

3) **限流算法策略**：虽然当前使用Guava RateLimiter，但可扩展为策略模式支持令牌桶、漏桶、滑动窗口等算法；

4) **负载均衡策略**：`GatewayServer.getOne()`当前使用随机策略，可扩展为轮询、加权轮询、最小连接等策略。

### 如何实现HTTP和Dubbo的协议策略？
通过策略模式实现：

1) **统一接口**：`BaseConnection`定义`send()`方法返回`CompletableFuture<Result<?>>`；

2) **HTTP策略**：`HTTPConnection`持有`HTTPExecutor`，使用Apache HttpAsyncClient发送HTTP请求；

3) **Dubbo策略**：`DubboConnection`持有`DubboExecutor`，使用泛化调用`$invokeAsync()`；

4) **策略选择**：`ExecutorHandler.createConnection()`根据`httpStatement.getIsHttp()`选择策略；

5) **扩展性**：新增gRPC协议只需实现`BaseConnection`接口。

### 如何实现限流算法的策略？
虽然当前使用Guava RateLimiter，但可通过策略模式扩展：

1) **策略接口**：定义`RateLimitStrategy`接口，包含`tryAcquire()`方法；

2) **具体策略**：实现`TokenBucketStrategy`（令牌桶）、`LeakyBucketStrategy`（漏桶）、`SlidingWindowStrategy`（滑动窗口）；

3) **策略工厂**：根据配置创建对应策略实例；

4) **策略切换**：通过配置中心动态切换限流算法；

5) **组合策略**：支持多种算法组合使用。

### 如何实现缓存策略的选择？
项目使用双缓存策略：

1) **L1缓存策略**：使用Hutool的LFU缓存，淘汰最不常用的数据；

2) **L2缓存策略**：使用Redis，支持分布式共享；

3) **策略选择**：先查L1，未命中查L2，再未命中查数据库；

4) **扩展性**：可实现`CacheStrategy`接口支持LRU、FIFO等策略；

5) **配置化**：通过`maxCache`参数配置L1缓存容量。

## 113. 工厂模式的应用

### 工厂模式在这个项目中的应用场景有哪些？
1) **执行器工厂**：`HTTPExecutorSpiFinder`和`DubboExecutorSpiFinder`通过SPI机制创建执行器实例；

2) **连接工厂**：`ExecutorHandler.createConnection()`根据协议类型创建`HTTPConnection`或`DubboConnection`；

3) **HTTP客户端工厂**：`HttpClientFactory.createHttpClient()`创建配置好的HTTP客户端；

4) **Dubbo服务工厂**：`DefaultDubboExecutor`中通过`ReferenceConfig`创建GenericService实例。

### 如何使用工厂模式创建执行器？
通过SPI工厂模式：

1) **SPI配置**：在`META-INF/services/`目录下配置实现类；

2) **工厂类**：`HTTPExecutorSpiFinder`使用`ServiceLoader.load()`加载实现类；

3) **单例模式**：使用双重检查锁实现单例，避免重复创建；

4) **延迟初始化**：第一次调用`getInstance()`时才创建实例；

5) **参数注入**：通过反射调用`setClient()`注入依赖。代码：`executor = load.findFirst().orElseThrow()`。

### 如何使用工厂模式创建连接对象？
简单工厂模式：

1) **工厂方法**：`ExecutorHandler.createConnection(boolean isHttp, String serverAddr, String url)`；

2) **条件判断**：根据`isHttp`参数决定创建哪种连接；

3) **HTTP连接**：`new HTTPConnection(config.getAsyncHttpClient(), "http://" + serverAddr + url)`；

4) **Dubbo连接**：`new DubboConnection(config.getDubboServiceMap(), dubboAddr)`；

5) **封装细节**：调用方无需关心连接创建细节，只需传入参数。

### 如何实现工厂的扩展？
1) **SPI扩展**：在`META-INF/services/`下添加新的实现类配置；

2) **接口扩展**：新协议实现`BaseConnection`和`BaseExecutor`接口；

3) **工厂方法扩展**：在`createConnection()`中添加新的分支判断；

4) **配置驱动**：通过配置文件指定使用哪个实现类；

5) **插件化**：将扩展打包为独立jar，通过类加载器动态加载。

## 114. 观察者模式的应用

### 观察者模式在这个项目中的应用场景有哪些？
主要通过Redis Pub/Sub实现：

1) **限流配置更新**：网关中心发布限流配置更新消息，所有网关核心订阅并更新本地配置；

2) **接口配置更新**：接口信息变更时发布消息，网关核心更新缓存；

3) **服务上下线通知**：服务实例上下线时通知网关中心更新Nginx配置；

4) **权重调整通知**：权重变更时通知所有节点更新负载均衡配置。

### 如何使用Redis Pub/Sub实现观察者模式？
1) **发布者**：网关中心通过`redisTemplate.convertAndSend("rate-limit-config-update", message)`发布消息；

2) **订阅者**：网关核心实现`MessageListener`接口，在`onMessage()`中处理消息；

3) **订阅注册**：通过`RedisMessageListenerContainer`注册监听器和频道；

4) **消息格式**：使用JSON格式传输配置信息；

5) **异步处理**：使用`@Async`注解异步处理消息，避免阻塞。

### 如何实现事件的发布和订阅？
1) **定义事件**：定义消息格式，如`{"type":"UPDATE","limitType":"INTERFACE","limitTarget":"/api/test"}`；

2) **发布事件**：`redisTemplate.convertAndSend(channel, JSON.toJSONString(event))`；

3) **订阅事件**：`container.addMessageListener(listener, new PatternTopic(channel))`；

4) **处理事件**：在`onMessage()`中解析JSON并执行相应逻辑；

5) **事件过滤**：根据事件类型过滤处理。

### 如何处理观察者的异常？
1) **异常捕获**：在`onMessage()`中使用try-catch捕获所有异常；

2) **日志记录**：`log.error("处理限流配置更新消息失败", e)`记录异常；

3) **不抛出异常**：避免异常影响其他消息处理；

4) **重试机制**：关键操作失败时可实现重试；

5) **降级处理**：配置更新失败时使用旧配置，不影响服务可用性。

## 115. 装饰器模式的应用

### 装饰器模式在这个项目中的应用场景有哪些？
项目中装饰器模式应用较少，但可在以下场景使用：

1) **Result装饰**：可对Result对象添加额外字段（如traceId、timestamp）；

2) **日志装饰**：为Handler添加日志记录功能；

3) **缓存装饰**：为Executor添加缓存功能；

4) **重试装饰**：为Connection添加重试功能；

5) **监控装饰**：为关键方法添加性能监控。

### 如何使用装饰器模式增强功能？
以缓存装饰为例：

1) **定义装饰器**：`CachedExecutor implements BaseExecutor`；

2) **持有被装饰对象**：`private final BaseExecutor executor`；

3) **增强逻辑**：在`execute()`中先查缓存，未命中调用`executor.execute()`；

4) **透明性**：装饰器实现相同接口，对调用方透明；

5) **链式装饰**：可多层装饰，如`new RetryExecutor(new CachedExecutor(new DefaultHTTPExecutor()))`。

### 如何实现装饰器的链式调用？
1) **统一接口**：所有装饰器实现相同接口；

2) **构造注入**：装饰器构造函数接收被装饰对象；

3) **委托调用**：装饰器调用被装饰对象的方法；

4) **增强逻辑**：在委托前后添加增强逻辑；

5) **多层嵌套**：`new A(new B(new C()))`实现多层装饰。例如：`new LogExecutor(new CacheExecutor(new RetryExecutor(new DefaultHTTPExecutor())))`。

### 装饰器模式与继承的区别是什么？
1) **灵活性**：装饰器可动态组合，继承是静态的；

2) **扩展性**：装饰器符合开闭原则，继承可能导致类爆炸；

3) **职责**：装饰器单一职责，继承可能违反单一职责；

4) **运行时**：装饰器可运行时选择，继承编译时确定；

5) **组合**：装饰器支持多层组合，继承只能单继承（Java）。装饰器更灵活但代码复杂度更高。

## 116. 代理模式的应用

### 代理模式在这个项目中的应用场景有哪些？
1) **Dubbo泛化调用**：`GenericService`是Dubbo提供的代理接口，无需依赖服务接口即可调用；

2) **HTTP客户端代理**：Apache HttpClient内部使用代理模式管理连接；

3) **Spring AOP代理**：Spring通过动态代理实现事务、日志等切面；

4) **连接池代理**：连接池返回的连接是代理对象，close()时归还连接而非真正关闭。

### 如何使用代理模式实现Dubbo的泛化调用？
1) **创建引用配置**：`ReferenceConfig<GenericService> reference = new ReferenceConfig<>()`；

2) **设置泛化**：`reference.setGeneric("true")`启用泛化调用；

3) **获取代理**：`GenericService service = reference.get()`获取代理对象；

4) **泛化调用**：`service.$invokeAsync(methodName, parameterTypes, args)`无需依赖接口；

5) **缓存代理**：将GenericService缓存到`ConcurrentHashMap`避免重复创建。

### 如何实现动态代理？
Java提供两种动态代理：

1) **JDK动态代理**：`Proxy.newProxyInstance(classLoader, interfaces, invocationHandler)`，要求目标类实现接口；

2) **CGLIB代理**：通过继承目标类生成子类，不要求接口；

3) **InvocationHandler**：实现`invoke()`方法，在方法调用前后添加逻辑；

4) **方法拦截**：可选择性拦截特定方法；

5) **性能**：JDK代理性能略优于CGLIB。

### 代理模式的性能影响有多大？
1) **JDK代理**：性能损耗约5-10%，主要是反射调用开销；

2) **CGLIB代理**：首次创建较慢（生成字节码），后续调用性能接近原生；

3) **Dubbo泛化调用**：相比直接调用性能损耗约10-20%，但换来了灵活性；

4) **优化**：缓存代理对象、减少反射调用、使用方法句柄；

5) **权衡**：在网关场景下，网络I/O是瓶颈，代理开销可忽略。

## 117. 单例模式的应用

### 单例模式在这个项目中的应用场景有哪些？
1) **全局配置**：`GlobalConfiguration`通过Spring管理为单例；

2) **执行器单例**：`HTTPExecutorSpiFinder`使用双重检查锁实现单例；

3) **工具类单例**：`NginxConfUtil`、`JwtUtils`等工具类为单例；

4) **连接池单例**：HTTP连接池、Dubbo服务缓存为单例；

5) **Spring Bean**：所有`@Component`默认为单例。

### 如何实现线程安全的单例？
项目使用双重检查锁：

```java
private static volatile HTTPExecutor executor;
public static HTTPExecutor getInstance(CloseableHttpAsyncClient client) {
    if (executor == null) {
        synchronized (HTTPExecutorSpiFinder.class) {
            if (executor == null) {
                executor = load.findFirst().orElseThrow();
            }
        }
    }
    return executor;
}
```

关键点：

1) `volatile`保证可见性；

2) 双重检查减少锁竞争；

3) 类锁保证线程安全；

4) 延迟初始化节省资源。

### 单例模式的缺点是什么？
1) **全局状态**：单例是全局状态，可能导致隐式依赖；

2) **测试困难**：单例难以Mock，影响单元测试；

3) **并发问题**：单例的可变状态需要考虑线程安全；

4) **生命周期**：单例生命周期与应用相同，可能导致内存泄漏；

5) **违反单一职责**：单例既负责业务逻辑又负责实例管理。建议使用Spring管理单例，避免手动实现。

### 如何测试单例模式？
1) **Spring测试**：使用`@SpringBootTest`，Spring自动管理单例；

2) **反射重置**：通过反射将单例字段设为null，重新初始化；

3) **Mock框架**：使用PowerMock mock静态方法和私有构造函数；

4) **依赖注入**：将单例作为依赖注入，测试时注入Mock对象；

5) **避免单例**：优先使用Spring管理Bean，避免手动实现单例。

## 118. 模板方法模式的应用

### 模板方法模式在这个项目中的应用场景有哪些？
主要在`BaseHandler`中应用：

1) **Handler模板**：`BaseHandler.channelRead()`定义处理流程模板；

2) **子类实现**：`AuthorizationHandler`、`ExecutorHandler`等实现`handle()`方法；

3) **资源管理**：模板方法统一管理资源释放；

4) **异常处理**：模板方法统一处理异常；

5) **扩展点**：子类只需实现`handle()`，无需关心其他逻辑。

### BaseHandler类如何使用模板方法模式？
```java
public abstract class BaseHandler<T> extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        try {
            handle(ctx, ctx.channel(), (T) msg);  // 调用子类实现
        } finally {
            if (this instanceof ResultHandler) {
                ReferenceCountUtil.release(msg);  // 资源释放
            }
        }
    }
    protected abstract void handle(ChannelHandlerContext ctx, Channel channel, T request);
}
```

模板方法`channelRead()`定义流程，子类实现`handle()`。

### 如何实现模板方法的扩展？
1) **钩子方法**：在模板方法中调用钩子方法，子类可选择性覆盖；

2) **抽象方法**：子类必须实现的方法；

3) **默认实现**：提供默认实现，子类可覆盖；

4) **回调接口**：通过接口回调实现扩展；

5) **策略注入**：将可变部分抽象为策略，通过构造函数注入。例如：`CustomPreHandler.isFailFast()`是钩子方法，默认返回true。

### 模板方法模式的优缺点是什么？
**优点**：

1) **代码复用**：公共逻辑在父类实现，避免重复；

2) **扩展性**：子类只需实现特定方法；

3) **控制反转**：父类控制流程，子类实现细节；

4) **符合开闭原则**：新增子类无需修改父类。


**缺点**：

1) **继承依赖**：子类依赖父类实现；

2) **灵活性**：模板方法固定流程，难以改变；

3) **类数量**：每个变体需要一个子类。适合流程固定、细节可变的场景。

