# 36 实战编码问题

## 181. 实现一个简单的限流器
- 如何实现一个基于令牌桶的限流器？
- 如何实现一个基于滑动窗口的限流器？
- 如何实现一个线程安全的限流器？
- 如何测试限流器的正确性？

## 182. 实现一个缓存系统
- 如何实现一个LFU缓存？
- 如何实现缓存的过期机制？
- 如何实现缓存的淘汰策略？
- 如何测试缓存系统的性能？

## 183. 实现一个异步HTTP客户端
- 如何实现一个异步HTTP客户端？
- 如何实现连接池的管理？
- 如何实现请求的超时控制？
- 如何实现异常的处理？

## 184. 实现一个分布式ID生成器
- 如何实现Snowflake算法？
- 如何处理时钟回拨？
- 如何实现节点ID的动态分配？
- 如何测试ID生成器的性能？

## 185. 实现一个服务注册与发现系统
- 如何实现服务的注册？
- 如何实现服务的发现？
- 如何实现心跳检测？
- 如何实现故障转移？

## 186. 实现一个请求路由系统
- 如何实现请求的路由？
- 如何实现负载均衡？
- 如何实现路由规则的配置？
- 如何实现路由规则的热更新？

## 187. 实现一个请求拦截器链
- 如何实现拦截器链的构建？
- 如何实现拦截器的执行？
- 如何实现拦截器的跳过？
- 如何实现拦截器的异常处理？

## 188. 实现一个熔断器
- 如何实现熔断器的状态机？
- 如何实现熔断器的计数？
- 如何实现熔断器的恢复？
- 如何测试熔断器的功能？

## 189. 实现一个重试机制
- 如何实现指数退避的重试？
- 如何实现重试的次数限制？
- 如何实现重试的条件判断？
- 如何测试重试机制？

## 190. 实现一个请求去重系统
- 如何实现请求的去重？
- 如何实现去重的存储？
- 如何实现去重的过期机制？
- 如何测试去重系统的性能？

## 项目实践解答

### 181. 实现一个简单的限流器

#### 如何实现一个基于令牌桶的限流器？
项目中的`DistributedRateLimiter`已实现令牌桶算法。核心逻辑：

1) 使用Guava `RateLimiter`实现本地限流，以固定速率生成令牌；

2) 使用Redis Lua脚本实现分布式限流，保证原子性；

3) 本地限流器设置为配置值的1.2倍，给Redis限流器留出空间；

4) 非阻塞尝试获取令牌，失败则拒绝请求。

#### 如何实现一个基于滑动窗口的限流器？
项目中的`DistributedRateLimiter`支持滑动窗口算法。实现方式：

1) 使用Redis有序集合(Sorted Set)存储请求时间戳；

2) 通过Lua脚本删除时间窗口外的请求记录；

3) 统计窗口内的请求数，超过阈值则拒绝；

4) 自动设置过期时间，避免内存泄漏。

#### 如何实现一个线程安全的限流器？
1) 使用`ConcurrentHashMap`存储限流器缓存，保证线程安全；

2) 使用`computeIfAbsent()`原子操作创建限流器；

3) 使用Redis Lua脚本保证分布式环境下的原子性；

4) 使用`AtomicInteger`或`AtomicLong`记录计数；

5) 避免使用普通HashMap和synchronized关键字。

#### 如何测试限流器的正确性？
1) **单元测试**：测试本地限流器的令牌生成速率是否正确；

2) **集成测试**：测试本地+Redis分布式限流的协同效果；

3) **压力测试**：使用JMeter或Gatling模拟高并发请求，验证限流效果；

4) **边界测试**：测试限流阈值边界情况；

5) **故障测试**：测试Redis异常时的降级策略。

### 182. 实现一个缓存系统

#### 如何实现一个LFU缓存？
项目中的`GlobalConfiguration`已实现LFU缓存。实现方式：

1) 使用`Map<K, LFUNode<K, V>>`存储缓存数据；

2) 使用`Map<Integer, LinkedHashSet<LFUNode<K, V>>>`维护频率表；

3) 记录每个节点的访问频率和最后访问时间；

4) 当容量满时，删除最低频率且最久未使用的节点；

5) 支持TTL和最大空闲时间的自动过期。

#### 如何实现缓存的过期机制？
1) **TTL过期**：记录缓存创建时间，定期检查是否超过TTL；

2) **空闲过期**：记录最后访问时间，超过最大空闲时间则过期；

3) **定时清理**：使用定时任务定期清理过期缓存；

4) **惰性删除**：访问时检查是否过期，过期则删除；

5) **Redis过期**：使用Redis的EXPIRE命令自动过期。

#### 如何实现缓存的淘汰策略？
项目支持多种淘汰策略：

1) **LFU**：删除最低频率的缓存，当前已实现；

2) **LRU**：删除最久未使用的缓存；

3) **FIFO**：删除最先进入的缓存；

4) **随机**：随机删除缓存；

5) **大小限制**：当缓存大小超过限制时触发淘汰。

#### 如何测试缓存系统的性能？
1) **命中率测试**：统计缓存命中率，目标>90%；

2) **延迟测试**：测试缓存访问延迟，目标<1ms；

3) **吞吐量测试**：测试缓存系统的吞吐量，目标>100k ops/s；

4) **内存测试**：监控缓存占用的内存大小；

5) **淘汰测试**：验证淘汰策略的正确性。

### 183. 实现一个异步HTTP客户端

#### 如何实现一个异步HTTP客户端？
项目中的`DefaultHTTPExecutor`已实现异步HTTP客户端。实现方式：

1) 使用Apache `HttpAsyncClient`替代同步`HttpClient`；

2) 基于NIO的异步网络通信，不阻塞线程；

3) 使用`CompletableFuture`处理异步结果；

4) 支持GET、POST、PUT、DELETE等HTTP方法；

5) 返回`CompletableFuture<Result<?>>`供调用者处理。

#### 如何实现连接池的管理？
1) **连接池创建**：使用`PoolingAsyncClientConnectionManager`管理异步连接池；

2) **连接复用**：复用已建立的连接，减少连接创建开销；

3) **连接限制**：设置最大连接数(如500)和单个路由最大连接数；

4) **连接回收**：定期清理空闲连接，释放资源；

5) **连接超时**：设置连接超时时间，避免连接泄漏。

#### 如何实现请求的超时控制？
1) **连接超时**：设置连接建立的超时时间；

2) **请求超时**：设置请求执行的超时时间；

3) **读超时**：设置读取响应的超时时间；

4) **CompletableFuture超时**：使用`orTimeout()`设置异步操作超时；

5) **超时处理**：超时时返回错误结果，不阻塞线程。

#### 如何实现异常的处理？
1) **异常捕获**：使用try-catch捕获异常；

2) **异常转换**：将异常转换为Result对象返回；

3) **异常日志**：记录异常信息便于调试；

4) **异常降级**：异常时返回默认值或缓存值；

5) **异常重试**：支持失败重试机制。

### 184. 实现一个分布式ID生成器

#### 如何实现Snowflake算法？
Snowflake算法生成64位ID：

1) **时间戳**：41位表示毫秒级时间戳(可用69年)；

2) **数据中心ID**：5位表示数据中心(0-31)；

3) **机器ID**：5位表示机器(0-31)；

4) **序列号**：12位表示序列(0-4095)；

5) **符号位**：1位符号位(始终为0)。实现时需要位移和按位或操作组合这些部分。

#### 如何处理时钟回拨？
1) **检测回拨**：比较当前时间戳与上次时间戳，如果小于则发生回拨；

2) **等待恢复**：等待系统时间恢复到正常水平；

3) **异常处理**：如果等待超时，抛出异常或使用备用方案；

4) **序列号递增**：在同一毫秒内递增序列号，避免ID重复；

5) **时间同步**：定期与NTP服务器同步时间。

#### 如何实现节点ID的动态分配？
1) **中心分配**：通过网关中心分配节点ID，存储在Redis中；

2) **自动注册**：服务启动时向网关中心注册，获取唯一的节点ID；

3) **心跳续约**：定期发送心跳，续约节点ID的有效期；

4) **故障转移**：节点宕机时，其他节点可接管其ID；

5) **ID回收**：节点下线时，回收其ID供其他节点使用。

#### 如何测试ID生成器的性能？
1) **生成速度**：测试单位时间内生成的ID数量，目标>100k/s；

2) **唯一性**：生成大量ID，验证没有重复；

3) **有序性**：验证ID是否单调递增；

4) **并发性**：多线程并发生成ID，验证线程安全性；

5) **时钟回拨**：模拟时钟回拨，验证处理逻辑。

### 185. 实现一个服务注册与发现系统

#### 如何实现服务的注册？
项目中的`server-find-sdk`已实现服务注册。实现方式：

1) 服务启动时扫描自定义注解(如`@GatewayService`)；

2) 提取接口信息(URL、方法名、参数类型等)；

3) 向网关中心上传接口信息；

4) 网关中心存储到数据库和Redis；

5) 服务定期发送心跳续约，保持注册状态。

#### 如何实现服务的发现？
1) **主动拉取**：网关定时从数据库拉取接口信息，更新到Redis和本地缓存；

2) **被动推送**：网关中心修改配置后，通过Redis Pub/Sub推送给所有网关节点；

3) **缓存策略**：使用L1(内存)+L2(Redis)多级缓存，提高查询速度；

4) **缓存更新**：收到推送消息后立即更新本地缓存；

5) **缓存过期**：定期清理过期缓存，避免内存泄漏。

#### 如何实现心跳检测？
1) **心跳发送**：服务每15秒发送一次心跳到网关中心；

2) **心跳存储**：网关中心将心跳信息存储到Redis，设置30秒过期时间；

3) **心跳检测**：网关定期检查Redis中的心跳信息，判断服务是否在线；

4) **自动下线**：心跳过期后自动触发服务下线事件；

5) **告警通知**：服务下线时发送告警通知。

#### 如何实现故障转移？
1) **健康检查**：定期检查后端服务的健康状态；

2) **故障检测**：连续失败N次则标记为故障；

3) **自动转移**：故障时自动转移请求到其他健康的服务实例；

4) **恢复检测**：定期尝试恢复故障服务，恢复后重新加入负载均衡；

5) **告警通知**：故障和恢复时发送告警通知。

### 186. 实现一个请求路由系统

#### 如何实现请求的路由？
项目中的`ExecutorHandler`已实现请求路由。实现方式：

1) 从请求URI中提取接口路径；

2) 从缓存中查询对应的接口配置(HttpStatement)；

3) 根据配置判断是HTTP还是Dubbo协议；

4) 创建对应的连接对象(HTTPConnection或DubboConnection)；

5) 调用连接对象发送请求到后端服务。

#### 如何实现负载均衡？
1) **权重轮询**：根据服务实例的权重进行轮询分配；

2) **最少连接**：选择当前连接数最少的实例；

3) **响应时间**：选择响应时间最短的实例；

4) **IP哈希**：根据客户端IP哈希选择实例，保证同一客户端总是路由到同一实例；

5) **随机**：随机选择一个实例。

#### 如何实现路由规则的配置？
1) **数据库存储**：将路由规则存储到数据库；

2) **Redis缓存**：将规则缓存到Redis，提高查询速度；

3) **本地缓存**：使用LFU缓存在网关本地缓存规则；

4) **配置管理**：提供API接口管理路由规则(增删改查)；

5) **权限控制**：只有管理员可以修改路由规则。

#### 如何实现路由规则的热更新？
1) **配置变更**：网关中心修改路由规则后存储到数据库和Redis；

2) **事件发布**：发布配置变更事件到Redis Pub/Sub频道；

3) **事件监听**：网关核心监听配置变更事件；

4) **缓存更新**：收到事件后立即更新本地缓存；

5) **无需重启**：无需重启应用，配置立即生效。

### 187. 实现一个请求拦截器链

#### 如何实现拦截器链的构建？
项目中的`ServerHandlerInitializer`已实现拦截器链。实现方式：

1) 使用Netty的`ChannelPipeline`构建处理器链；

2) 按顺序添加处理器：`AuthorizationHandler` → `PreExecutorHandler` → `ExecutorHandler` → `PostExecutorHandler` → `ResultHandler`；

3) 每个处理器通过`ctx.fireChannelRead()`传递给下一个；

4) 支持动态添加和移除处理器。

#### 如何实现拦截器的执行？
1) **顺序执行**：处理器按添加顺序依次执行；

2) **链式调用**：每个处理器处理完调用`ctx.fireChannelRead()`传递给下一个；

3) **异步执行**：使用`CompletableFuture`支持异步处理；

4) **并行执行**：前置处理器支持并行执行多个处理器；

5) **串行执行**：后置处理器按顺序串行执行。

#### 如何实现拦截器的跳过？
1) **条件判断**：在处理器中判断是否需要跳过；

2) **直接转发**：如果跳过则直接调用`ctx.fireChannelRead()`转发给下一个处理器；

3) **标记跳过**：使用请求属性标记是否跳过某个处理器；

4) **配置控制**：通过配置文件控制是否启用某个处理器；

5) **注解控制**：使用注解标记某个接口是否需要经过某个处理器。

#### 如何实现拦截器的异常处理？
1) **异常捕获**：在处理器中使用try-catch捕获异常；

2) **异常转换**：将异常转换为Result对象返回；

3) **异常日志**：记录异常信息便于调试；

4) **异常转发**：异常时调用`ctx.fireExceptionCaught()`转发给异常处理器；

5) **异常恢复**：异常时返回默认值或缓存值，继续处理。

### 188. 实现一个熔断器

#### 如何实现熔断器的状态机？
熔断器有三个状态：

1) **CLOSED**：正常状态，请求通过；

2) **OPEN**：熔断状态，请求被拒绝；

3) **HALF_OPEN**：半开状态，允许部分请求通过以测试服务是否恢复。状态转移：CLOSED → OPEN(失败率超过阈值) → HALF_OPEN(等待超时) → CLOSED(测试成功) 或 OPEN(测试失败)。

#### 如何实现熔断器的计数？
1) **请求计数**：记录总请求数；

2) **失败计数**：记录失败请求数；

3) **成功计数**：记录成功请求数；

4) **时间窗口**：在固定时间窗口内统计计数；

5) **计数重置**：时间窗口过期后重置计数。

#### 如何实现熔断器的恢复？
1) **超时恢复**：OPEN状态下等待超时时间(如30秒)后转为HALF_OPEN；

2) **测试恢复**：HALF_OPEN状态下允许部分请求通过，如果成功则转为CLOSED；

3) **快速失败**：HALF_OPEN状态下如果失败则立即转为OPEN；

4) **手动恢复**：提供API手动重置熔断器状态；

5) **自动恢复**：定期检查服务状态，自动恢复。

#### 如何测试熔断器的功能？
1) **正常测试**：验证CLOSED状态下请求通过；

2) **熔断测试**：模拟失败请求，验证转为OPEN状态；

3) **恢复测试**：验证OPEN状态下等待超时后转为HALF_OPEN；

4) **半开测试**：验证HALF_OPEN状态下的请求处理；

5) **并发测试**：多线程并发测试熔断器的线程安全性。

### 189. 实现一个重试机制

#### 如何实现指数退避的重试？
1) **重试次数**：设置最大重试次数(如3次)；

2) **退避时间**：第N次重试的等待时间为`baseDelay * 2^(N-1)`，如100ms、200ms、400ms；

3) **随机抖动**：在退避时间基础上加入随机抖动，避免雷鸣羊群效应；

4) **最大延迟**：设置最大延迟时间，避免等待过长；

5) **异步重试**：使用`CompletableFuture`实现异步重试。

#### 如何实现重试的次数限制？
1) **最大重试次数**：设置最大重试次数，超过则放弃；

2) **重试计数**：记录当前重试次数；

3) **重试判断**：每次重试前检查是否超过最大次数；

4) **重试日志**：记录每次重试的信息；

5) **重试告警**：重试次数过多时发送告警。

#### 如何实现重试的条件判断？
1) **可重试异常**：只对特定异常进行重试(如网络异常、超时)；

2) **不可重试异常**：某些异常不重试(如参数错误、权限拒绝)；

3) **HTTP状态码**：根据HTTP状态码判断是否重试(如5xx重试，4xx不重试)；

4) **自定义条件**：支持自定义重试条件；

5) **幂等性检查**：只对幂等操作进行重试。

#### 如何测试重试机制？
1) **成功重试**：模拟第一次失败，第二次成功，验证重试成功；

2) **全部失败**：模拟所有重试都失败，验证最终返回失败；

3) **超时重试**：验证重试的等待时间是否正确；

4) **并发重试**：多线程并发重试，验证线程安全性；

5) **性能测试**：测试重试对性能的影响。

### 190. 实现一个请求去重系统

#### 如何实现请求的去重？
1) **生成请求ID**：为每个请求生成唯一ID(如使用Snowflake算法)；

2) **客户端传递**：客户端在请求头中传递请求ID；

3) **服务端检查**：服务端检查请求ID是否已处理过；

4) **去重存储**：将已处理的请求ID存储到Redis或数据库；

5) **返回缓存结果**：如果请求ID已存在，直接返回缓存的结果。

#### 如何实现去重的存储？
1) **Redis存储**：使用Redis的Set或Hash存储已处理的请求ID，支持快速查询；

2) **数据库存储**：将请求ID存储到数据库，支持持久化；

3) **混合存储**：热数据存储到Redis，冷数据存储到数据库；

4) **分布式存储**：使用分布式缓存(如Memcached)支持多节点查询；

5) **索引优化**：为请求ID建立索引，提高查询速度。

#### 如何实现去重的过期机制？
1) **TTL过期**：设置请求ID的过期时间(如24小时)，过期后自动删除；

2) **Redis EXPIRE**：使用Redis的EXPIRE命令设置过期时间；

3) **定时清理**：使用定时任务定期清理过期的请求ID；

4) **惰性删除**：访问时检查是否过期，过期则删除；

5) **业务逻辑**：根据业务需求设置合理的过期时间。

#### 如何测试去重系统的性能？
1) **查询速度**：测试请求ID查询的延迟，目标<1ms；

2) **吞吐量**：测试单位时间内处理的请求数，目标>100k/s；

3) **存储容量**：测试系统能存储的最大请求ID数量；

4) **并发性**：多线程并发查询，验证线程安全性；

5) **准确性**：验证去重的准确性，不能误删或误保留。

