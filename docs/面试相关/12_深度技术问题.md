# 12 深度技术问题

## 51. Netty事件驱动模型

### Netty的事件驱动模型是如何工作的？
1) **事件循环**: EventLoop不断循环检查是否有事件发生；

2) **事件处理**: 当有事件发生时，调用相应的处理器处理；

3) **非阻塞**: 使用NIO Selector实现非阻塞I/O；

4) **高效**: 一个线程可处理多个连接；

5) **异步**: 事件处理是异步的，不阻塞其他事件。

### Boss线程和Worker线程各自的职责是什么？
**Boss线程**:

1) 接收客户端连接；

2) 为每个连接创建Channel；

3) 将Channel分配给Worker线程。


**Worker线程**:

1) 处理Channel的读写事件；

2) 执行ChannelHandler处理器；

3) 处理业务逻辑。

### 如何配置Boss线程和Worker线程的数量？
1) **Boss线程**: 通常设置为1，因为只需接收连接；

2) **Worker线程**: 通常设置为CPU核心数或2倍CPU核心数；

3) **配置方式**: 在GlobalConfiguration中配置bossThreads和workerThreads；

4) **默认值**: Boss=1, Worker=4；

5) **调优**: 根据实际负载调整线程数。

### 线程数量对性能的影响有多大？
1) **线程过少**: 无法充分利用CPU，吞吐量低；

2) **线程过多**: 线程切换开销大，反而降低性能；

3) **最优值**: 通常为CPU核心数或2倍CPU核心数；

4) **监控**: 监控线程使用率，找到最优值；

5) **动态调整**: 可根据负载动态调整线程数。

## 52. ChannelHandler处理链

### ChannelHandler处理链的执行流程是什么？
1) **入站事件**: 从客户端接收数据，按处理器顺序执行；

2) **出站事件**: 向客户端发送数据，按处理器逆序执行；

3) **处理器链**: 多个处理器组成一条链，依次处理；

4) **传播**: 处理完后调用ctx.fireChannelRead()传播到下一个处理器；

5) **终止**: 如果不调用fireChannelRead()，处理链终止。

### 如何在处理链中添加新的处理器？
1) **获取Pipeline**: 从Channel获取ChannelPipeline；

2) **添加处理器**: 使用addLast()、addFirst()等方法添加处理器；

3) **指定位置**: 可在指定处理器前后添加；

4) **移除处理器**: 使用remove()方法移除处理器；

5) **替换处理器**: 使用replace()方法替换处理器。

### 处理器的执行顺序如何确定？
1) **添加顺序**: 按添加顺序执行入站处理器；

2) **逆序执行**: 出站处理器按逆序执行；

3) **@Order注解**: 使用@Order注解指定执行顺序；

4) **canRunParallel**: 某些处理器可并行执行；

5) **依赖关系**: 有依赖关系的处理器必须串行执行。

### 如何在处理器之间传递数据？
1) **Channel属性**: 使用Channel.attr()存储数据；

2) **AttributeKey**: 使用AttributeKey作为键；

3) **上下文传递**: 通过ChannelHandlerContext传递；

4) **消息对象**: 将数据包装在消息对象中传递；

5) **线程本地**: 使用ThreadLocal存储线程相关数据。

## 53. Channel属性存储

### 为什么使用Channel属性存储请求相关的数据？
1) **生命周期**: Channel属性与Channel生命周期一致，自动清理；

2) **线程安全**: Channel属性是线程安全的；

3) **性能**: 比使用Map存储性能更好；

4) **隔离**: 不同Channel的属性相互隔离；

5) **便利**: 在处理链中任何地方都可访问。

### AttributeKey的作用是什么？
1) **唯一标识**: AttributeKey是属性的唯一标识；

2) **类型安全**: 提供类型安全的属性访问；

3) **创建方式**: 使用AttributeKey.valueOf()创建；

4) **复用**: 同一个AttributeKey可在多个Channel中使用；

5) **性能**: AttributeKey是不可变的，可安全共享。

### 如何安全地存储和获取Channel属性？
1) **存储**: 使用channel.attr(key).set(value)存储；

2) **获取**: 使用channel.attr(key).get()获取；

3) **检查**: 获取前检查属性是否存在；

4) **异常处理**: 处理属性不存在的情况；

5) **同步**: 属性操作是原子的，无需额外同步。

### Channel属性的生命周期是什么？
1) **创建**: Channel创建时属性为空；

2) **存储**: 在处理器中存储属性；

3) **访问**: 在处理链中任何地方都可访问；

4) **清理**: Channel关闭时自动清理属性；

5) **垃圾回收**: 属性对象由GC回收。

## 54. Netty内存管理

### Netty的内存池是如何工作的？
1) **对象池**: 复用ByteBuf对象，减少创建销毁开销；

2) **内存池**: 复用内存块，减少内存分配；

3) **自动回收**: 使用引用计数自动回收；

4) **性能**: 内存池显著提升性能；

5) **配置**: 可配置内存池的大小。

### 直接内存和堆内存各自的优缺点是什么？
**直接内存**:

1) 优点：I/O性能好，避免复制；

2) 缺点：分配慢，不受GC管理。


**堆内存**:

1) 优点：分配快，受GC管理；

2) 缺点：I/O性能差，需要复制。

### 如何避免内存泄漏？
1) **引用计数**: 正确使用引用计数，及时释放；

2) **release()**: 使用完ByteBuf后调用release()；

3) **try-finally**: 在finally中释放资源；

4) **监控**: 监控内存使用情况，发现泄漏；

5) **工具**: 使用内存分析工具检测泄漏。

### 如何监控内存使用情况？
1) **JVM监控**: 使用JVM监控工具(如JConsole)；

2) **堆内存**: 监控堆内存使用率；

3) **直接内存**: 监控直接内存使用率；

4) **GC**: 监控GC频率和耗时；

5) **告警**: 内存使用超过阈值时告警。

## 55. HTTP请求解析

### Netty如何解析HTTP请求？
1) **HttpRequestDecoder**: 将字节流解析为HTTP请求对象；

2) **HttpObjectAggregator**: 聚合HTTP消息为FullHttpRequest；

3) **分阶段**: 先解析请求行，再解析请求头，最后解析请求体；

4) **流式处理**: 支持流式处理大文件；

5) **错误处理**: 解析错误时返回错误响应。

### FullHttpRequest对象包含哪些信息？
1) **请求行**: HTTP方法、URI、HTTP版本；

2) **请求头**: 所有请求头信息；

3) **请求体**: 请求体内容；

4) **查询参数**: URI中的查询参数；

5) **Cookie**: 请求中的Cookie信息。

### 如何提取请求头、请求体和查询参数？
1) **请求头**: 使用request.headers().get(name)获取；

2) **请求体**: 使用request.content()获取ByteBuf，转换为字符串；

3) **查询参数**: 解析URI中的查询字符串；

4) **工具类**: 使用RequestParameterUtil工具类提取；

5) **编码**: 注意处理字符编码。

### 如何处理大文件上传？
1) **流式处理**: 使用流式处理，不一次性加载到内存；

2) **分块上传**: 支持分块上传，逐块处理；

3) **进度跟踪**: 跟踪上传进度；

4) **超时控制**: 设置上传超时时间；

5) **错误恢复**: 支持断点续传。

## 56. HTTP响应构建

### 如何构建HTTP响应？
1) **创建对象**: 使用DefaultFullHttpResponse创建响应对象；

2) **设置状态码**: 设置HTTP状态码(200、404等)；

3) **设置响应头**: 添加响应头信息；

4) **设置响应体**: 设置响应体内容；

5) **发送**: 使用channel.writeAndFlush()发送响应。

### DefaultFullHttpResponse对象的各个参数是什么？
1) **protocolVersion**: HTTP协议版本(HTTP/1.1)；

2) **status**: HTTP状态码(HttpResponseStatus.OK)；

3) **content**: 响应体内容(ByteBuf)；

4) **headers**: 响应头信息；

5) **trailingHeaders**: 尾部头信息。

### 如何设置响应头和响应体？
1) **响应头**: 使用response.headers().set(name, value)设置；

2) **Content-Type**: 设置响应内容类型；

3) **Content-Length**: 设置响应体长度；

4) **响应体**: 使用Unpooled.wrappedBuffer()包装内容；

5) **编码**: 注意处理字符编码。

### 如何处理响应的编码问题？
1) **字符编码**: 使用UTF-8编码；

2) **设置Content-Type**: 在响应头中指定charset；

3) **ByteBuf编码**: 将字符串编码为字节；

4) **解码**: 客户端根据Content-Type解码；

5) **测试**: 测试中文等特殊字符的处理。

