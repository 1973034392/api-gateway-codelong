# 17 安全性问题

## 81. JWT令牌的安全性

### JWT令牌如何防止被篡改？
使用HMAC256算法对Header和Payload进行签名，签名密钥为`safeSecret`。任何对Header或Payload的修改都会导致签名验证失败。验证时使用`JWT.require(algorithm).build().verify(token)`重新计算签名并比对，不匹配则拒绝请求。

### JWT令牌如何防止被伪造？
签名密钥`safeSecret`仅服务端持有，客户端无法获取。即使攻击者知道算法和Payload结构，没有密钥也无法生成有效签名。同时在Payload中包含`safe-key`声明，验证时需同时匹配配置的`safeKey`，实现双重校验。

### JWT令牌的过期时间如何设置？
设置为30天：`TOKEN_EXPIRE_TIME = 30L * 24 * 60 * 60 * 1000`。生成时添加`withExpiresAt(new Date(System.currentTimeMillis() + TOKEN_EXPIRE_TIME))`声明。验证时JWT库自动检查过期时间，过期令牌抛出`TokenExpiredException`，返回401错误。

### 如何处理令牌的刷新？
本项目未实现刷新机制，令牌过期需重新获取。标准实现：

1) 使用双Token机制(AccessToken+RefreshToken)；

2) AccessToken短期(如1小时)，RefreshToken长期(如30天)；

3) AccessToken过期时使用RefreshToken换取新Token；

4) RefreshToken也过期则需重新登录；

5) RefreshToken使用一次后立即失效。

## 82. 密钥管理

### 系统中的密钥有哪些？
1) **JWT签名密钥**：`safeSecret`，用于JWT签名和验证；

2) **安全组标识**：`safeKey`，标识服务身份；

3) **Redis密码**：保护Redis访问；

4) **数据库密码**：保护数据库访问；

5) **SSH密钥**：用于远程操作Nginx服务器。

### 如何安全地存储密钥？
1) **配置文件加密**：使用Jasypt等工具加密配置文件中的敏感信息；

2) **环境变量**：通过环境变量注入密钥，避免硬编码；

3) **配置中心**：使用Apollo/Nacos等配置中心，支持密钥加密存储；

4) **密钥管理服务**：使用专业的KMS(Key Management Service)；

5) **权限控制**：限制配置文件访问权限，仅运维人员可见。

### 如何实现密钥的轮换？
1) **双密钥机制**：同时支持新旧两个密钥，验证时都尝试；

2) **灰度切换**：先在部分节点使用新密钥，验证无误后全量切换；

3) **版本标识**：在Token中添加密钥版本号，根据版本选择密钥；

4) **自动化流程**：通过脚本自动化密钥轮换流程；

5) **通知机制**：密钥变更时通知所有相关服务。

### 如何处理密钥的泄露？
1) **立即轮换**：发现泄露立即更换所有密钥；

2) **撤销令牌**：将已签发的Token加入黑名单；

3) **审计日志**：检查泄露期间的访问日志，排查异常访问；

4) **通知用户**：通知受影响用户重新认证；

5) **事后分析**：分析泄露原因，完善安全措施。

## 83. 请求签名验证

### 如何实现请求的签名验证？
本项目使用JWT作为签名机制。标准API签名实现：

1) 客户端将请求参数按字典序排列；

2) 拼接为字符串并加上密钥；

3) 使用MD5/SHA256计算签名；

4) 将签名放入请求头；

5) 服务端使用相同算法计算签名并比对。

### 签名验证的流程是什么？
1) **提取Token**：从`Authorization`头提取JWT令牌；

2) **解析Token**：使用JWT库解析Token结构；

3) **验证签名**：使用`safeSecret`重新计算签名并比对；

4) **检查过期**：验证Token是否过期；

5) **验证声明**：检查Payload中的`safe-key`是否匹配配置；

6) **放行或拒绝**：验证通过则继续处理，失败则返回401。

### 如何防止签名被伪造？
1) **密钥保密**：签名密钥仅服务端持有，不暴露给客户端；

2) **强加密算法**：使用HMAC256等安全算法；

3) **时间戳验证**：检查请求时间戳，拒绝过期请求；

4) **随机数(Nonce)**：防止重放攻击；

5) **HTTPS传输**：使用HTTPS防止中间人攻击窃取Token。

### 如何处理签名验证失败？
1) **返回401**：返回HTTP 401 Unauthorized状态码；

2) **错误信息**：返回"没有权限访问该接口"或"Token无效"；

3) **日志记录**：记录验证失败的请求信息和原因；

4) **监控告警**：验证失败次数过多时触发告警，可能是攻击行为；

5) **限流保护**：对频繁验证失败的IP进行限流或封禁。

## 84. 权限控制

### 如何实现接口级的权限控制？
通过`HttpStatement.isAuth`标志控制接口是否需要认证。在`AuthorizationHandler`中检查该标志，需要认证的接口验证JWT令牌，不需要的直接放行。接口配置存储在数据库，通过Redis缓存，支持动态配置每个接口的权限要求。

### 如何实现基于角色的权限控制？
标准RBAC实现：

1) **角色定义**：定义管理员、普通用户等角色；

2) **权限分配**：为每个角色分配接口访问权限；

3) **用户绑定**：用户绑定一个或多个角色；

4) **Token携带**：JWT Payload中包含用户角色信息；

5) **权限检查**：验证用户角色是否有权访问接口。本项目可通过自定义前置处理器实现。

### 如何实现基于资源的权限控制？
1) **资源标识**：为每个资源(接口、数据)分配唯一标识；

2) **权限矩阵**：维护用户-资源-操作的权限矩阵；

3) **动态检查**：请求时检查用户对该资源的操作权限；

4) **细粒度控制**：支持读、写、删除等不同操作权限；

5) **继承机制**：支持权限继承，简化配置。

### 如何处理权限的动态更新？
1) **Redis Pub/Sub**：权限配置变更时发布消息，所有网关节点实时更新；

2) **缓存失效**：更新权限时清除相关缓存；

3) **版本号机制**：为权限配置添加版本号，避免旧配置覆盖新配置；

4) **定时同步**：定时从数据库同步权限配置；

5) **热更新**：无需重启应用即可生效。

## 85. 安全组标识的验证

### 安全组标识如何验证？
1) **提取Token**：从`Authorization`头提取JWT令牌；

2) **验证签名**：使用`safeSecret`验证签名，确保Token未被篡改；

3) **提取safeKey**：从Token Payload中提取`safe-key`声明；

4) **比对配置**：将提取的`safeKey`与配置的`config.getSafeKey()`比对；

5) **双重验证**：签名和safeKey都验证通过才放行。

### 如何防止安全组标识被伪造？
1) **签名保护**：safeKey存储在JWT Payload中，通过HMAC256签名保护，篡改会导致签名失败；

2) **密钥保密**：签名密钥`safeSecret`仅服务端持有；

3) **双重校验**：同时验证签名和safeKey，增加伪造难度；

4) **HTTPS传输**：使用HTTPS防止Token被窃取；

5) **Token缓存**：已验证的Token缓存30分钟，减少重复验证开销。

### 如何处理安全组标识的过期？
安全组标识随JWT令牌一起过期，过期时间30天。过期后：

1) **验证失败**：JWT库自动检测过期并抛出异常；

2) **返回401**：返回"Token已过期"错误；

3) **重新获取**：客户端需重新调用注册接口获取新Token；

4) **自动续期**：服务提供者通过心跳机制自动续期；

5) **监控告警**：Token频繁过期时告警，可能是配置问题。

### 如何实现安全组标识的轮换？
1) **重新注册**：服务提供者重新调用注册接口获取新的safeKey和safeSecret；

2) **双密钥支持**：网关同时支持新旧两个密钥，验证时都尝试；

3) **灰度切换**：先在部分服务使用新密钥，验证无误后全量切换；

4) **通知机制**：密钥变更时通过Redis Pub/Sub通知所有节点；

5) **自动化流程**：通过脚本定期自动轮换密钥。

