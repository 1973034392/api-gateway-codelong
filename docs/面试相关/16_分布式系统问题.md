# 16 分布式系统问题

## 76. 分布式ID生成

### Snowflake算法的基本原理是什么？
64位ID分为4部分：1位符号位(固定0) + 41位时间戳(毫秒级,从2020-09-13起算) + 10位节点ID(支持1024个节点) + 12位序列号(同一毫秒内支持4096个ID)。通过位运算组装：`(时间差 << 22) | (节点ID << 12) | 序列号`，保证全局唯一、趋势递增、高性能。

### 为什么需要改进传统的Snowflake算法？
传统Snowflake需手动配置节点ID，容器化环境下难以管理且易冲突。本项目使用Redis自增动态分配节点ID：`redisTemplate.opsForValue().increment(key)`，自动获取唯一ID，设置1天过期时间防止ID耗尽，解决了节点管理和扩展性问题。

### 如何使用Redis实现节点ID的动态分配？
应用启动时调用`initNodeId()`，使用Redis的`increment`命令自增获取唯一节点ID，key格式为`snowflake:node_id:应用名`。获取后设置86400秒过期时间，防止节点ID耗尽。节点ID范围0-1023(10位)，支持1024个实例同时运行。

### 节点ID耗尽时如何处理？
通过设置Redis key过期时间(1天)自动回收离线节点的ID。当节点ID超过1023时抛出`RuntimeException("无法获取有效节点ID")`。实际场景中1024个节点足够使用，如需更多可调整`nodeIdBits`配置，但会减少序列号位数。

## 77. 时钟回拨问题

### 什么是时钟回拨？
系统时间被人为或NTP服务调整导致当前时间戳小于上次生成ID的时间戳。例如上次生成ID时时间戳为1000，当前时间戳变为995，回拨了5ms。

### 时钟回拨对ID生成的影响是什么？
可能生成重复ID。因为Snowflake算法依赖时间戳保证唯一性，时间回拨后可能生成与之前相同的时间戳+序列号组合，导致ID冲突，破坏全局唯一性。

### 如何检测时钟回拨？
在`nextId()`方法中比较当前时间戳与上次时间戳：`if (timestamp < lastTimestamp)`即检测到回拨。记录回拨时间：`clockBack = lastTimestamp - timestamp`，并记录warn日志。

### 如何处理时钟回拨？
允许5ms内的小幅回拨，通过`Thread.sleep(clockBack << 1)`等待双倍回拨时间后重新获取时间戳。超过5ms的回拨抛出`RuntimeException("时钟回拨异常")`拒绝生成ID，避免ID重复，需人工介入处理。

## 78. 分布式锁

### 系统中是否使用了分布式锁？
本项目未显式使用分布式锁。限流使用Redis Lua脚本保证原子性，配置更新通过Redis Pub/Sub实现最终一致性，节点ID分配使用Redis自增命令天然保证原子性，无需额外加锁。

### 如何使用Redis实现分布式锁？
标准实现：

1) 使用`SET key value NX EX seconds`获取锁；

2) value设为唯一标识(UUID)防止误删；

3) 设置过期时间防止死锁；

4) 释放锁时先GET比对value再DEL；

5) 使用Lua脚本保证释放操作原子性。

### 分布式锁的可靠性如何保证？
1) 设置合理的过期时间；

2) 使用唯一标识防止误删他人的锁；

3) 使用Lua脚本保证操作原子性；

4) 考虑使用Redisson等成熟框架，支持锁续期、可重入等特性；

5) 对于强一致性要求可使用RedLock算法。

### 如何处理分布式锁的死锁？
1) 必须设置过期时间，即使持锁进程崩溃也能自动释放；

2) 使用看门狗机制自动续期，防止业务执行时间超过锁过期时间；

3) 监控锁持有时间，超时告警；

4) 提供手动释放锁的管理接口；

5) 记录锁的持有者信息便于排查。

## 79. 分布式事务

### 系统中是否涉及分布式事务？
本项目未涉及强一致性分布式事务。采用最终一致性方案：配置变更先写数据库再发Redis消息，通过定时同步任务保证最终一致；服务注册失败时SDK自动重试；限流配置通过版本号机制避免冲突。

### 如何保证分布式事务的一致性？
常见方案：

1) **2PC/3PC**：强一致但性能差；

2) **TCC**：Try-Confirm-Cancel三阶段，业务侵入性强；

3) **Saga**：长事务拆分+补偿机制；

4) **本地消息表**：本地事务+消息队列保证最终一致；

5) **最大努力通知**：重试+人工介入。

### 如何处理分布式事务的失败？
1) **重试机制**：自动重试失败的操作；

2) **补偿机制**：执行反向操作回滚；

3) **人工介入**：记录失败日志，人工处理；

4) **监控告警**：失败时及时告警；

5) **幂等性**：保证重试不会产生副作用。

### 如何实现分布式事务的回滚？
1) **TCC模式**：预留Cancel方法实现回滚；

2) **Saga模式**：为每个正向操作定义补偿操作；

3) **本地消息表**：记录操作状态，失败时执行补偿；

4) **版本号机制**：通过版本号检测冲突并回滚；

5) **最终一致性**：通过定时任务修正不一致数据。

## 80. 服务间通信

### 网关与后端服务如何通信？
支持HTTP和Dubbo双协议。HTTP使用Apache HttpAsyncClient异步调用，连接池配置最大200连接；Dubbo使用泛化调用`$invokeAsync`，无需依赖服务接口，端口固定20880。通过`BaseConnection`接口统一抽象，返回`CompletableFuture`异步结果。

### 网关与网关中心如何通信？
1) **服务注册**：网关核心启动时通过HTTP POST调用`/gateway-group-detail/register`注册；

2) **心跳续约**：定时15秒发送心跳，网关中心更新Redis过期时间30秒；

3) **配置同步**：网关中心配置变更后发布Redis Pub/Sub消息，网关核心监听并更新本地缓存；

4) **接口拉取**：定时从网关中心拉取最新接口配置。

### 如何保证通信的可靠性？
1) **连接池复用**：HTTP连接池避免频繁创建连接；

2) **超时控制**：设置连接超时5秒，Socket超时5秒；

3) **重试机制**：关键操作失败自动重试；

4) **熔断降级**：连续失败时熔断，避免雪崩；

5) **健康检查**：通过心跳检测服务健康状态，自动剔除故障节点。

### 如何处理通信的失败？
1) **异常捕获**：捕获所有通信异常并记录日志；

2) **降级处理**：限流器异常时降级为本地限流；

3) **重试策略**：服务注册失败时自动重试；

4) **故障转移**：负载均衡自动切换到其他健康节点；

5) **监控告警**：通信失败率超过阈值时触发告警。

